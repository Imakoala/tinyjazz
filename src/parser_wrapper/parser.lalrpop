use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::ast::*;
    use std::path::PathBuf;
grammar(file_id: usize);
NonEmptyComma<T>: Vec<T> = { 
    <v:(<T> ",")+> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

ParCommaOrSingle<T> : Vec<T> = {
    "(" <v:(<T> ",")*> <e:T?> ")" => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
    <T> => vec![<>]
};

Loc<T> : Loc<T> = {
    <l:@L> <val:T> <r:@R> => {
        Loc {
            loc: (file_id, l, r),
            value: val,
        }
    }
}

pub Program : Program = {
    <imports:Import*> => Program {
        imports, 
        modules: HashMap::new(),
        functions: HashMap::new(),
        global_consts: HashMap::new(),
    },
    <mut p:Program> <func:Function> => {
        p.functions.insert((*func.name).clone(), func);
        p
    },
    <mut p:Program> <module:Module> => {
        p.modules.insert(module.name.clone(), module);
        p
    },
    <mut p:Program> <c:GlobalConst> => {
        p.global_consts.insert(c.var.clone(), c.cons);
        p
    }
}

Module: Module = {
    "module" <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <ins:Comma<Arg>> ")" "=" <out:ParCommaOrSingle<Arg>>
    <s:SharedVar*>
    <ext:Loc<ExtModule>*>
    <auto:Automaton*> 
    => {
        Module {
            name : name.strip_suffix("(").unwrap().to_string(),
            inputs: ins, 
            outputs: out,
            shared: s.into_iter().flatten().collect(),
            extern_modules: ext, 
            automata: auto
        }
    }
}

If : IfStruct = {
    "if" <c:Const> "then" <v1:Statement*> "end if" => IfStruct {
        condition : c,
        if_block : v1,
        else_block: Vec::new()
    },
    "if" <c:Const> "then" <v1:Statement*> "else" <v2:Statement*> "end if" => IfStruct {
        condition : c,
        if_block : v1,
        else_block: v2
    }
}

Ram : RamStruct = {
    "ram<" <c1:Const> "," <c2:Const> ">(" <e1:Loc<Expr>> "," <e2:Loc<Expr>> "," <e3:Loc<Expr>> "," <e4:Loc<Expr>> ")" =>
    RamStruct {
        addr_size: c1,
        word_size: c2,
        read_addr: Box::new(e1),
        write_enable: Box::new(e2),
        write_addr: Box::new(e3),
        write_data: Box::new(e4),
    }
}

Rom : RomStruct = {
    "rom<" <c1:Const> "," <c2:Const> ">(" <e:Loc<Expr>> ")" =>
    RomStruct {
        addr_size: c1,
        word_size: c2,
        read_addr: Box::new(e),
    }
}

Var : String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string()
}

FnCall : FnCall = {
    <name_lloc:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*<"> <name_rloc:@R> <v1:Loc<Comma<Const>>> ">(" <v2:Loc<Comma<Loc<Expr>>>> ")" => FnCall {
        name: Loc {
            loc: (file_id, name_lloc, name_rloc),
            value: name.strip_suffix("<").unwrap().to_string()
        },
        args: v2, 
        static_args: v1,
    },
    <name_lloc:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_rloc:@R> <v:Loc<Comma<Loc<Expr>>>> ")" => FnCall {
        name: Loc {
            loc: (file_id, name_lloc, name_rloc),
            value: name.strip_suffix("(").unwrap().to_string()
        },
        args: v, 
        static_args: Loc {
            loc: (file_id, name_rloc, name_rloc),
            value: Vec::new(),
        }
    },
}

Bool : bool = {
    "1" => true,
    "true"=> true,
    "0" => false,
    "false"=> false,
}

ConstExpr: ConstExpr = {
    Bool => ConstExpr::Known(vec![<>]),
    "[" <Comma<Bool>> "]" => ConstExpr::Known(<>),
    "[" <b:Bool> ";" <c:Const> "]" => ConstExpr::Unknown(b, c)
}

Num: i32 = {
    <s:r"[0-9]+"> => i32::from_str(s).unwrap(),
    "0" => 0,
    "1" => 1
}

Unit: Expr = {
    <ConstExpr> => Expr::Const(<>),
    <e:Loc<Unit>> "[" <c1:Const> ".." <c2:Const> "]" => Expr::Slice(Box::new(e), c1, c2),
    "(" <Expr> ")",
    "mux(" <e1:Loc<Expr>> "," <e2:Loc<Expr>> "," <e3:Loc<Expr>> ")" => Expr::Mux(Box::new(e1), Box::new(e2), Box::new(e3)),
    "reg(" <Expr> ")" => Expr::Reg(Box::new(<>)),
    <Ram> => Expr::Ram(<>),
    <Rom> => Expr::Rom(<>),
    <FnCall> => Expr::FnCall(<>),
    <Loc<Var>> => Expr::Var(<>),
};

Xor : () = {
    "xor" => (),
    "^" => ()
}

XorExpr: Expr = {
    <e1:Loc<XorExpr>> Xor <e2:Loc<Unit>> => Expr::BiOp(BiOp::Xor, Box::new(e1), Box::new(e2)),
    Unit
}

And : () = {
    "and" => (),
    "*" => ()
}

AndExpr: Expr = {
    <e1:Loc<AndExpr>> And <e2:Loc<XorExpr>> => Expr::BiOp(BiOp::And, Box::new(e1), Box::new(e2)),
    XorExpr
}

NandExpr: Expr = {
    <e1:Loc<NandExpr>> "nand" <e2:Loc<AndExpr>> => Expr::BiOp(BiOp::Nand, Box::new(e1), Box::new(e2)),
    AndExpr
}

Or : () = {
    "or" => (),
    "+" => ()
}

OrExpr: Expr = {
    <e1:Loc<OrExpr>> Or <e2:Loc<NandExpr>> => Expr::BiOp(BiOp::Or, Box::new(e1), Box::new(e2)),
    NandExpr
}

Expr : Expr = {
    "not" <Unit> => Expr::Not(Box::new(<>)),
    <e1:Loc<Expr>> "." <e2:Loc<OrExpr>> => Expr::BiOp(BiOp::Concat, Box::new(e1), Box::new(e2)),
    OrExpr
}

AddOp: ConstBiOp = {
    "+" => ConstBiOp::Plus,
    "-" => ConstBiOp::Minus,
}

MulOp: ConstBiOp = {
    "*" => ConstBiOp::Times,
    "/" => ConstBiOp::Div,
}

CompOp: ConstBiOp = {
    "<" => ConstBiOp::Lt,
    ">" => ConstBiOp::Gt,
    "<=" => ConstBiOp::Le,
    ">=" => ConstBiOp::Ge,
    "==" => ConstBiOp::Eq,
    "!=" => ConstBiOp::Neq,
}

Const: Const = {
    <l:Const> <op:AddOp> <r:Loc<ConstFactor>> => Const::BiOp(op, Box::new(l),  Box::new(r)),
    ConstFactor,
};

ConstFactor: Const = {
    <l:ConstTerm> <op:CompOp> <r:Loc<ConstTerm>> => Const::BiOp(op, Box::new(l),  Box::new(r)),
    <l:ConstFactor> <op:MulOp> <r:Loc<ConstTerm>> => Const::BiOp(op, Box::new(l),  Box::new(r)),
    ConstTerm,
};

ConstTerm: Const = {
    <Loc<Var>> => Const::Var(<>),
    <Num> => Const::Value(<>),
    "(" <Const> ")",
};

Statement: Statement = {
    <v:Loc<Var>> "=" <e:Loc<Expr>> => Statement::Assign(vec![VarAssign {
        var : v, 
        expr : e,
    }]),
    "(" <mut v:NonEmptyComma<Loc<Var>>> ")" "=" "(" <mut e:NonEmptyComma<Loc<Expr>>> ")" =>? 
    {
        if v.len() != e.len() {
            Err(ParseError::User {
                    error : "The variable tuple and the expression tuple must have the same length"
                })
            }
        else {
            Ok(Statement::Assign(v.drain(..).zip(e.drain(..))
            .map(|(var, expr)| VarAssign {
                var, 
                expr
            })
            .collect()))
        }
    },
    <If> => Statement::If(<>),
    "(" <v:NonEmptyComma<Loc<Var>>> ")" "=" <f:FnCall> => Statement::FnAssign(FnAssign {
        vars: v,
        f,
    })


};

Transition : (Loc<Expr>, Loc<Var>, bool) = {
    "|" <e:Loc<Expr>> "->" <reset:"reset"?> <v:Loc<Var>> => (e, v, reset.is_some()),
    "|" <l:@L> "default" <r:@R> "->" <reset:"reset"?> <v:Loc<Var>> => 
    (
        Loc {
            loc: (file_id, l, r),
            value: Expr::Const(ConstExpr::Known(vec![true]))
        },
        v,
        reset.is_some()
    )
}
Node : (Var, Node) = {
    "node" <name:Var> <s:Statement*> "transition" <t:Transition*> => 
    (name, 
    Node {
        statements : s, 
        transitions : t
    })
}

Automaton : Automaton = {
    "automaton" <mut n: Loc<Node>*> => {
        let mut map = HashMap::new();
        for node in n.drain(..) {
            map.insert((*node).0.clone(), Loc {value : (*node).1.clone(), loc: node.loc});
        }
        map
    }
}
Arg : Arg = {
    <Var> => Arg {
        name : <>, 
        size : Const::Value(1)
    },
    <v:Var> "[" <c:Const> "]" => Arg {
        name : v, 
        size : c
    }
}

Function : Function = {
    "fn" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_loc_r:@R> <args:Comma<Arg>> ")" 
    "=" <ret:ParCommaOrSingle<Arg>> 
    <s:Statement*> =>
    Function {
        name: Loc {
            loc : (file_id, name_loc_l, name_loc_r),
            value: name.strip_suffix("(").unwrap().to_string(), 
        },
        static_args : Vec::new(), 
        args,
        return_vars: ret, 
        statements: s,
    },
    "fn" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*<"> <name_loc_r:@R> <static_args:Comma<Var>> ">("
    <args:Comma<Arg>> ")" 
    "=" <ret:ParCommaOrSingle<Arg>> 
    <s:Statement*> =>
    Function {
        name: Loc {
            loc : (file_id, name_loc_l, name_loc_r),
            value: name.strip_suffix("<").unwrap().to_string(), 
        },
        static_args, 
        args,
        return_vars: ret, 
        statements: s,
    }
}

SharedVar : Vec<VarAssign> = {
    "shared" <mut v:ParCommaOrSingle<Loc<Arg>>> "=" <mut e:ParCommaOrSingle<Loc<ConstExpr>>> =>? {
        if e.len() == 0 {
            Ok(v.drain(..)
            .map(|arg| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const(ConstExpr::Unknown(false, arg.size.clone())), loc: arg.loc}
            }).collect())
        }
        else if e.len() == 1 {
            Ok(v.drain(..)
            .map(|arg| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const((*e[0]).clone()), loc: e[0].loc}
            }).collect())
        }
        else if v.len() != e.len() {
            Err(ParseError::User {
                error : "The variable tuple and the expression tuple must have the same length"
            })
        }
        else {
            Ok(v.drain(..)
            .zip(e.drain(..))
            .map(|(arg, expr)| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const((*expr).clone()), loc: expr.loc}
            }).collect())
        }
    },
}

ExtModule: ExtModule = {
    <out:Loc<ParCommaOrSingle<Loc<Var>>>> "=" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_loc_r:@R> <ins:Loc<Comma<Loc<Var>>>> ")" => 
    ExtModule {
        inputs: ins,
        outputs: out,
        name: Loc {value: name.strip_suffix("(").unwrap().to_string(), loc: (file_id, name_loc_l, name_loc_r)},
    }
}

Import : Import = {
    <s:r#"import[ ]+[^/\n "]*(/[^/\n "]*)*"#> => 
    PathBuf::from(
        s.strip_prefix("import")
        .unwrap()
        .split_whitespace()
        .collect::<String>()
    ),
    <s:r#"import[ ]+"[^/\n"]*(/[^/\n"]*)*""#> => 
    PathBuf::from(
        s.strip_prefix("import")
        .unwrap()
        .split_whitespace()
        .collect::<String>()
        .strip_prefix("\"")
        .unwrap()
        .strip_suffix("\"")
        .unwrap()
    )
}

GlobalConst : ConstVarAssign = {
    "const" <name:Var> "=" <c:Const> => ConstVarAssign {
        var : name, 
        cons : c
    }
}

// match {
//     r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
//     r"(\(\*([^*]|[\r\n]|(\*+([^*\)]|[\r\n])))*\*+\))|(//.*)" => { }, //skip (**) and // comments
// }