use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::ast::*;
    use std::path::PathBuf;
grammar(file_id: usize);
NonEmptyComma<T>: Vec<T> = { 
    <v:(<T> ",")+> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

ParCommaOrSingle<T> : Vec<T> = {
    "(" <v:(<T> ",")*> <e:T?> ")" => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
    <T> => vec![<>]
};

Loc<T> : Loc<T> = {
    <l:@L> <val:T> <r:@R> => {
        Loc {
            loc: (file_id, l, r),
            value: val,
        }
    }
}

pub Program : Program = {
    <imports:Import*> => Program {
        imports, 
        modules: HashMap::new(),
        functions: HashMap::new(),
        global_consts: HashMap::new(),
    },
    <mut p:Program> <func:Function> => {
        p.functions.insert((*func.name).clone(), func);
        p
    },
    <mut p:Program> <module:Module> => {
        p.modules.insert(module.name.clone(), module);
        p
    },
    <mut p:Program> <c:GlobalConst> => {
        p.global_consts.insert(c.var.clone(), c.cons);
        p
    }
}

Init : Vec<Loc<String>> = {
    "init" <ParCommaOrSingle<Loc<Var>>> => <>,
     => Vec::new()
}

Module: Module = {
    "module" <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <ins:Comma<Arg>> ")" "=" <out:ParCommaOrSingle<Arg>>
    <init: Init>
    <s:SharedVar*>
    <ext:Loc<ExtModule>*>
    <mut nodes:Node*> 
    => {
        Module {
            name : name.strip_suffix("(").unwrap().to_string(),
            inputs: ins, 
            outputs: out,
            shared: s.into_iter().flatten().collect(),
            extern_modules: ext, 
            nodes : nodes.drain(..).collect(),
            init_nodes: init
        }
    }
}

If : IfStruct = {
    "if" <c:Const> "then" <v1:Statement*> "end if" => IfStruct {
        condition : c,
        if_block : v1,
        else_block: Vec::new()
    },
    "if" <c:Const> "then" <v1:Statement*> "else" <v2:Statement*> "end if" => IfStruct {
        condition : c,
        if_block : v1,
        else_block: v2
    }
}

Ram : RamStruct = {
    "ram(" <e1:Loc<Expr>> "," <e2:Loc<Expr>> "," <e3:Loc<Expr>> "," <e4:Loc<Expr>> ")" =>
    RamStruct {
        read_addr: Box::new(e1),
        write_enable: Box::new(e2),
        write_addr: Box::new(e3),
        write_data: Box::new(e4),
    }
}

Rom : RomStruct = {
    "rom<" <c1:Const> ">(" <e:Loc<Expr>> ")" =>
    RomStruct {
        word_size: c1,
        read_addr: Box::new(e),
    }
}

Var : String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string()
}

FnCall : FnCall = {
    <name_lloc:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*<"> <name_rloc:@R> <v1:Loc<Comma<Const>>> ">(" <v2:Loc<Comma<Loc<Expr>>>> ")" => FnCall {
        name: Loc {
            loc: (file_id, name_lloc, name_rloc),
            value: name.strip_suffix("<").unwrap().to_string()
        },
        args: v2, 
        static_args: v1,
    },
    <name_lloc:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_rloc:@R> <v:Loc<Comma<Loc<Expr>>>> ")" => FnCall {
        name: Loc {
            loc: (file_id, name_lloc, name_rloc),
            value: name.strip_suffix("(").unwrap().to_string()
        },
        args: v, 
        static_args: Loc {
            loc: (file_id, name_rloc, name_rloc),
            value: Vec::new(),
        }
    },
}

Bool : bool = {
    "1" => true,
    "true"=> true,
    "0" => false,
    "false"=> false,
}

ConstExpr: ConstExpr = {
    Bool => ConstExpr::Known(vec![<>]),
    "[" <Comma<Bool>> "]" => ConstExpr::Known(<>),
    "[" <b:Bool> ";" <c:Loc<Const>> "]" => ConstExpr::Unknown(b, c)
}

Num: i32 = {
    <s:r"[0-9]+"> => i32::from_str(s).unwrap(),
    "0" => 0,
    "1" => 1
}

Unit: Expr = {
    <ConstExpr> => Expr::Const(<>),
    <e:Loc<Unit>> "[" <c1:Const> ".." <c2:Const> "]" => Expr::Slice(Box::new(e), c1, c2),
    <e:Loc<Unit>> "[" <c:Loc<Const>> "]" => 
    Expr::Slice(
        Box::new(e), 
        c.value.clone(), 
        Const::BiOp(
            ConstBiOp::Plus, 
            Box::new(c.value), 
            Box::new(Loc {
                value: Const::Value(1),
                loc: c.loc
            })
        )
    ),
    "(" <Expr> ")",
    "mux(" <e1:Loc<Expr>> "," <e2:Loc<Expr>> "," <e3:Loc<Expr>> ")" => Expr::Mux(Box::new(e1), Box::new(e2), Box::new(e3)),
    "reg(" <Expr> ")" => Expr::Reg(Box::new(<>)),
    <Ram> => Expr::Ram(<>),
    <Rom> => Expr::Rom(<>),
    <FnCall> => Expr::FnCall(<>),
    <Loc<Var>> => Expr::Var(<>),
};

Xor : () = {
    "xor" => (),
    "^" => ()
}

XorExpr: Expr = {
    <e1:Loc<XorExpr>> Xor <e2:Loc<Unit>> => Expr::BiOp(BiOp::Xor, Box::new(e1), Box::new(e2)),
    Unit
}

And : () = {
    "and" => (),
    "*" => ()
}

AndExpr: Expr = {
    <e1:Loc<AndExpr>> And <e2:Loc<XorExpr>> => Expr::BiOp(BiOp::And, Box::new(e1), Box::new(e2)),
    XorExpr
}

NandExpr: Expr = {
    <e1:Loc<NandExpr>> "nand" <e2:Loc<AndExpr>> => Expr::BiOp(BiOp::Nand, Box::new(e1), Box::new(e2)),
    AndExpr
}

Or : () = {
    "or" => (),
    "+" => ()
}

OrExpr: Expr = {
    <e1:Loc<OrExpr>> Or <e2:Loc<NandExpr>> => Expr::BiOp(BiOp::Or, Box::new(e1), Box::new(e2)),
    NandExpr
}

Expr : Expr = {
    "not" <Unit> => Expr::Not(Box::new(<>)),
    <e1:Loc<Expr>> "." <e2:Loc<OrExpr>> => Expr::BiOp(BiOp::Concat, Box::new(e1), Box::new(e2)),
    OrExpr
}

AddOp: ConstBiOp = {
    "+" => ConstBiOp::Plus,
    "-" => ConstBiOp::Minus,
}

MulOp: ConstBiOp = {
    "*" => ConstBiOp::Times,
    "/" => ConstBiOp::Div,
}

CompOp: ConstBiOp = {
    "<" => ConstBiOp::Lt,
    ">" => ConstBiOp::Gt,
    "<=" => ConstBiOp::Le,
    ">=" => ConstBiOp::Ge,
    "==" => ConstBiOp::Eq,
    "!=" => ConstBiOp::Neq,
}

BoolOp: ConstBiOp = {
    "&&" => ConstBiOp::And, 
    "||" => ConstBiOp::Or,
}


ConstCmp: Const = {
    <l:Const> <op:AddOp> <r:Loc<ConstFactor>> => Const::BiOp(op, Box::new(l),  Box::new(r)),
    ConstFactor,
};

ConstFactor: Const = {
    <l:ConstFactor> <op:MulOp> <r:Loc<ConstTerm>> => Const::BiOp(op, Box::new(l),  Box::new(r)),
    ConstTerm,
};

ConstTerm: Const = {
    <Loc<Var>> => Const::Var(<>),
    <Num> => Const::Value(<>),
    "(" <Const> ")",
};

Const: Const = {
    "(" <l:Const> <op: BoolOp> <r:Loc<Const>> ")" => Const::BiOp(op, Box::new(l),  Box::new(r)),
    "(" <l:Const> <op: CompOp> <r:Loc<Const>> ")" => Const::BiOp(op, Box::new(l),  Box::new(r)),
    ConstCmp,

}

Statement: Statement = {
    <v:Loc<Var>> "=" <e:Loc<Expr>> => Statement::Assign(vec![VarAssign {
        var : v, 
        expr : e,
    }]),
    "(" <mut v:NonEmptyComma<Loc<Var>>> ")" "=" "(" <mut e:NonEmptyComma<Loc<Expr>>> ")" =>? 
    {
        if v.len() != e.len() {
            Err(ParseError::User {
                    error : "The variable tuple and the expression tuple must have the same length"
                })
            }
        else {
            Ok(Statement::Assign(v.drain(..).zip(e.drain(..))
            .map(|(var, expr)| VarAssign {
                var, 
                expr
            })
            .collect()))
        }
    },
    <If> => Statement::If(<>),
    "(" <v:NonEmptyComma<Loc<Var>>> ")" "=" <f:FnCall> => Statement::FnAssign(FnAssign {
        vars: v,
        f,
    })


};

Transition : (Loc<Expr>, Loc<Var>, bool) = {
    "|" <e:Loc<Expr>> "->" <reset:"reset"?> <v:Loc<Var>> => (e, v, reset.is_some()),
    "|" <l:@L> "default" <r:@R> "->" <reset:"reset"?> <v:Loc<Var>> => 
    (
        Loc {
            loc: (file_id, l, r),
            value: Expr::Const(ConstExpr::Known(vec![true]))
        },
        v,
        reset.is_some()
    )
}
Node : Node = {
    <name:Loc<Var>> ":" <e:ExtModule*> <s:Statement*> "until" <t:Transition*> => 
    Node {
        name,
        extern_modules: e, 
        statements: s,
        transitions : t,
        weak: true
    },
    <name:Loc<Var>> ":" <e:ExtModule*> <s:Statement*> "unless" <t:Transition*> =>  
    Node {
        name,
        extern_modules: e, 
        statements: s, 
        transitions : t,
        weak: false
    },
}

Arg : Arg = {
    <v:Var> <l:@L> => Arg {
        name : v, 
        size : Loc {
            value: Const::Value(1),
            loc: (file_id, l, l)
        }
    },
    <v:Var> "[" <c:Loc<Const>> "]" => Arg {
        name : v, 
        size : c
    }
}

Function : Function = {
    "fn" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_loc_r:@R> <args:Comma<Arg>> ")" 
    "=" <ret:ParCommaOrSingle<Arg>> 
    <s:Statement*> =>
    Function {
        name: Loc {
            loc : (file_id, name_loc_l, name_loc_r),
            value: name.strip_suffix("(").unwrap().to_string(), 
        },
        static_args : Vec::new(), 
        args,
        return_vars: ret, 
        statements: s,
    },
    "fn" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*<"> <name_loc_r:@R> <static_args:Comma<Var>> ">("
    <args:Comma<Arg>> ")" 
    "=" <ret:ParCommaOrSingle<Arg>> 
    <s:Statement*> =>
    Function {
        name: Loc {
            loc : (file_id, name_loc_l, name_loc_r),
            value: name.strip_suffix("<").unwrap().to_string(), 
        },
        static_args, 
        args,
        return_vars: ret, 
        statements: s,
    }
}

SharedVar : Vec<VarAssign> = {
    "shared" <mut v:ParCommaOrSingle<Loc<Arg>>> "=" <mut e:ParCommaOrSingle<Loc<ConstExpr>>> =>? {
        if e.len() == 0 {
            Ok(v.drain(..)
            .map(|arg| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const(ConstExpr::Unknown(false, arg.size.clone())), loc: arg.loc}
            }).collect())
        }
        else if e.len() == 1 {
            Ok(v.drain(..)
            .map(|arg| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const((*e[0]).clone()), loc: e[0].loc}
            }).collect())
        }
        else if v.len() != e.len() {
            Err(ParseError::User {
                error : "The variable tuple and the expression tuple must have the same length"
            })
        }
        else {
            Ok(v.drain(..)
            .zip(e.drain(..))
            .map(|(arg, expr)| VarAssign {
                var : Loc {value: arg.name.clone(), loc: arg.loc},
                expr : Loc {value: Expr::Const((*expr).clone()), loc: expr.loc}
            }).collect())
        }
    },
}

ExtModule: ExtModule = {
    "use" <out:Loc<ParCommaOrSingle<Loc<Var>>>> "=" <name_loc_l:@L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*\("> <name_loc_r:@R> <ins:Loc<Comma<Loc<Var>>>> ")" => 
    ExtModule {
        inputs: ins,
        outputs: out,
        name: Loc {value: name.strip_suffix("(").unwrap().to_string(), loc: (file_id, name_loc_l, name_loc_r)},
    }
}

Import : Import = {
    <s:r#"import[ ]+[^/\n "]*(/[^/\n "]*)*"#> => 
    PathBuf::from(
        s.strip_prefix("import")
        .unwrap()
        .split_whitespace()
        .collect::<String>()
    ),
    <s:r#"import[ ]+"[^/\n"]*(/[^/\n"]*)*""#> => 
    PathBuf::from(
        s.strip_prefix("import")
        .unwrap()
        .split_whitespace()
        .collect::<String>()
        .strip_prefix("\"")
        .unwrap()
        .strip_suffix("\"")
        .unwrap()
    )
}

GlobalConst : ConstVarAssign = {
    "const" <name:Var> "=" <c:Const> => ConstVarAssign {
        var : name, 
        cons : c
    }
}

match {
    r"(\(\*([^*]|[\r\n]|(\*+([^*\)]|[\r\n])))*\*+\))|(//.*)" => { }, //skip (**) and // comments
}
else {
    r"\s*" => { }, //skip whitespaces
    _ //match the rest
}