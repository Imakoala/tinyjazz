const p = 16

fn inc<n>(in[n]) = (o[n], r)
    if (n == 1) then 
        o = not in
        r = in
    else
        (o_rec, r_rec) = inc<n-1>(in[1..n])
        i_n = in[0]
        o_n = r_rec ^ i_n
        r = r_rec and i_n
        o = o_n . o_rec
    end if

module main() = o[p]
    init n1
    shared o = [0; p]
    n1:
        (o, r) = inc<p>(o)
    until
        |o[p/2 - 1] -> n2
        |not o[p/2 - 1] -> n1
    
    n2:
        use o = m2(o)
    until 
        |1 -> n1

module m2(a[p]) = o[p]
    init n1
    shared o = [0; p]
    n1:
        o = not a
    until
        |o[5] -> n2
        |not o[5] -> n1
    n2:
        o = [0; p]
    until 
        |1 -> n1